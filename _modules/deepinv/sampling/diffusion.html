<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>deepinv.sampling.diffusion &mdash; deepinverse 0.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/deepinv_logolarge.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.physics.html">Physics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.utils.html">Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.loss.html">Loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.optim.html">Optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.pnp.html">PnP and RED algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.unfolded.html">Unfolded algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.sampling.html">Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.notation.html">Math Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deepinv.contributing.html">How to Contribute</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">deepinverse</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">deepinv.sampling.diffusion</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for deepinv.sampling.diffusion</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span> <span class="nn">deepinv.physics</span>
<span class="kn">from</span> <span class="nn">deepinv.sampling.langevin</span> <span class="kn">import</span> <span class="n">MonteCarlo</span>


<span class="k">class</span> <span class="nc">DiffusionSampler</span><span class="p">(</span><span class="n">MonteCarlo</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a diffusion method into a full Monte Carlo sampler</span>

<span class="sd">    Unlike diffusion methods, the resulting sampler computes the mean and variance of the distribution</span>
<span class="sd">    by running the diffusion multiple times.</span>

<span class="sd">    :param torch.nn.Module diffusion: a diffusion model</span>
<span class="sd">    :param int max_iter: the maximum number of iterations</span>
<span class="sd">    :param tuple clip: the clip range</span>
<span class="sd">    :param callable g_statistic: the algorithm computes mean and variance of the g function, by default :math:`g(x) = x`.</span>
<span class="sd">    :param float thres_conv: the convergence threshold for the mean and variance</span>
<span class="sd">    :param bool verbose: whether to print the progress</span>
<span class="sd">    :param bool save_chain: whether to save the chain</span>
<span class="sd">    :param int thinning: the thinning factor</span>
<span class="sd">    :param float burnin_ratio: the burnin ratio</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">diffusion</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="o">=</span><span class="mf">1e2</span><span class="p">,</span>
        <span class="n">clip</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="n">thres_conv</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span>
        <span class="n">g_statistic</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">save_chain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># generate an iterator</span>
        <span class="c1"># set the params of the base class</span>
        <span class="n">data_fidelity</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">diffusion</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="n">diffusion</span>

        <span class="k">def</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">physics</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">,</span> <span class="n">prior</span><span class="p">):</span>
            <span class="c1"># run one sampling kernel iteration</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">prior</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">physics</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">iterator</span><span class="p">,</span>
            <span class="n">prior</span><span class="p">,</span>
            <span class="n">data_fidelity</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">thinning</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">save_chain</span><span class="o">=</span><span class="n">save_chain</span><span class="p">,</span>
            <span class="n">burnin_ratio</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">clip</span><span class="o">=</span><span class="n">clip</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">thresh_conv</span><span class="o">=</span><span class="n">thres_conv</span><span class="p">,</span>
            <span class="n">g_statistic</span><span class="o">=</span><span class="n">g_statistic</span><span class="p">,</span>
        <span class="p">)</span>


<div class="viewcode-block" id="DDRM">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DDRM.html#deepinv.sampling.DDRM">[docs]</a>
<span class="k">class</span> <span class="nc">DDRM</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Denoising Diffusion Restoration Models (DDRM).</span>

<span class="sd">    This class implements the denoising diffusion restoration model (DDRM) described in https://arxiv.org/abs/2201.11793.</span>

<span class="sd">    The DDRM is a sampling method that uses a denoiser to sample from the posterior distribution of the inverse problem.</span>

<span class="sd">    It requires that the physics operator has a singular value decomposition, i.e.,</span>
<span class="sd">    it is :meth:`deepinv.physics.DecomposablePhysics` class.</span>

<span class="sd">    :param torch.nn.Module denoiser: a denoiser model that can handle different noise levels.</span>
<span class="sd">    :param list[int], numpy.array sigmas: a list of noise levels to use in the diffusion, they should be in decreasing</span>
<span class="sd">        order from 1 to 0.</span>
<span class="sd">    :param float eta: hyperparameter</span>
<span class="sd">    :param float etab: hyperparameter</span>
<span class="sd">    :param bool verbose: if True, print progress</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">denoiser</span><span class="p">,</span>
        <span class="n">sigmas</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="n">eta</span><span class="o">=</span><span class="mf">0.85</span><span class="p">,</span>
        <span class="n">etab</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DDRM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiser</span> <span class="o">=</span> <span class="n">denoiser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span> <span class="o">=</span> <span class="n">sigmas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sigmas</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">etab</span> <span class="o">=</span> <span class="n">etab</span>

<div class="viewcode-block" id="DDRM.forward">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DDRM.html#deepinv.sampling.DDRM.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">physics</span><span class="p">:</span> <span class="n">deepinv</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">DecomposablePhysics</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the diffusion to obtain a random sample of the posterior distribution.</span>

<span class="sd">        :param torch.Tensor y: the measurements.</span>
<span class="sd">        :param deepinv.physics.DecomposablePhysics physics: the physics operator, which must have a singular value</span>
<span class="sd">            decomposition.</span>
<span class="sd">        :param int seed: the seed for the random number generator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert physics.__class__ == deepinv.physics.DecomposablePhysics, &#39;The forward operator requires a singular value decomposition&#39;</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">physics</span><span class="o">.</span><span class="n">noise_model</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">):</span>
                <span class="n">sigma_noise</span> <span class="o">=</span> <span class="n">physics</span><span class="o">.</span><span class="n">noise_model</span><span class="o">.</span><span class="n">sigma</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma_noise</span> <span class="o">=</span> <span class="mf">0.01</span>

            <span class="k">if</span> <span class="n">physics</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">deepinv</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">Denoising</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span>
                    <span class="n">y</span>
                <span class="p">)</span>  <span class="c1"># TODO: fix for economic SVD decompositions (eg. Decolorize)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">physics</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">abs</span><span class="p">()]</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y_bar</span> <span class="o">=</span> <span class="n">physics</span><span class="o">.</span><span class="n">U_adjoint</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">case</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="n">sigma_noise</span>
            <span class="n">y_bar</span><span class="p">[</span><span class="n">case</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_bar</span><span class="p">[</span><span class="n">case</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask</span><span class="p">[</span><span class="n">case</span><span class="p">]</span>
            <span class="n">nsr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">nsr</span><span class="p">[</span><span class="n">case</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_noise</span> <span class="o">/</span> <span class="n">mask</span><span class="p">[</span><span class="n">case</span><span class="p">]</span>

            <span class="c1"># iteration 1</span>
            <span class="c1"># compute init noise</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_bar</span><span class="p">)</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y_bar</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mean</span><span class="p">[</span><span class="n">case</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_bar</span><span class="p">[</span><span class="n">case</span><span class="p">]</span>
            <span class="n">std</span><span class="p">[</span><span class="n">case</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">nsr</span><span class="p">[</span><span class="n">case</span><span class="p">]</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
            <span class="n">x_bar</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">std</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">y_bar</span><span class="p">)</span>
            <span class="n">x_bar_prev</span> <span class="o">=</span> <span class="n">x_bar</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

            <span class="c1"># denoise</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoiser</span><span class="p">(</span><span class="n">physics</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">x_bar</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)):</span>
                <span class="c1"># add noise in transformed domain</span>
                <span class="n">x_bar</span> <span class="o">=</span> <span class="n">physics</span><span class="o">.</span><span class="n">V_adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="n">case2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">case</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nsr</span><span class="p">))</span>
                <span class="n">case3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">case</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nsr</span><span class="p">))</span>

                <span class="c1"># n = np.prod(mask.shape)</span>
                <span class="c1"># print(f&#39;case: {case.sum()/n*100:.2f}, case2: {case2.sum()/n*100:.2f}, case3: {case3.sum()/n*100:.2f}&#39;)</span>

                <span class="n">mean</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">x_bar</span>
                    <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_bar_prev</span> <span class="o">-</span> <span class="n">x_bar</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">mean</span><span class="p">[</span><span class="n">case2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">x_bar</span><span class="p">[</span><span class="n">case2</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_bar</span><span class="p">[</span><span class="n">case2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_bar</span><span class="p">[</span><span class="n">case2</span><span class="p">])</span> <span class="o">/</span> <span class="n">nsr</span><span class="p">[</span><span class="n">case2</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">mean</span><span class="p">[</span><span class="n">case3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">etab</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_bar</span><span class="p">[</span><span class="n">case3</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">etab</span> <span class="o">*</span> <span class="n">y_bar</span><span class="p">[</span>
                    <span class="n">case3</span>
                <span class="p">]</span>

                <span class="n">std</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x_bar</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="n">std</span><span class="p">[</span><span class="n">case3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">nsr</span><span class="p">[</span><span class="n">case3</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">etab</span><span class="p">)</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

                <span class="n">x_bar</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">std</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">x_bar</span><span class="p">)</span>
                <span class="n">x_bar_prev</span> <span class="o">=</span> <span class="n">x_bar</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="c1"># denoise</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denoiser</span><span class="p">(</span><span class="n">physics</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">x_bar</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">x</span></div>
</div>



<div class="viewcode-block" id="DiffPIR">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DiffPIR.html#deepinv.sampling.DiffPIR">[docs]</a>
<span class="k">class</span> <span class="nc">DiffPIR</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Diffusion PnP Image Restoration (DiffPIR).</span>

<span class="sd">    This class implements the Diffusion PnP image restoration algorithm (DiffPIR) described</span>
<span class="sd">    in https://arxiv.org/abs/2305.08995.</span>

<span class="sd">    The DiffPIR algorithm is inspired on a half-quadratic splitting (HQS) plug-and-play algorithm, where the denoiser</span>
<span class="sd">    is a conditional diffusion denoiser, combined with a diffusion process. The algorithm writes as follows,</span>
<span class="sd">    for :math:`t` decreasing from :math:`T` to :math:`1`:</span>

<span class="sd">     .. math::</span>
<span class="sd">             \begin{equation*}</span>
<span class="sd">             \begin{aligned}</span>
<span class="sd">             x_{0}^{t} &amp;= D_{\theta}(x_t, \frac{\sqrt{1-\overline{\alpha}_t}}{\sqrt{\overline{\alpha}_t}}) \\</span>
<span class="sd">             \widehat{x}_{0}^{t} &amp;= \operatorname{prox}_{2 f(y, \cdot) /{\rho_t}}(x_{0}^{t}) \\</span>
<span class="sd">             \widehat{\varepsilon} &amp;= \left(x_t - \sqrt{\overline{\alpha}_t} \,\,</span>
<span class="sd">             \widehat{x}_{0}^t\right)/\sqrt{1-\overline{\alpha}_t} \\</span>
<span class="sd">             \varepsilon_t &amp;= \mathcal{N}(0, \mathbf{I}) \\</span>
<span class="sd">             x_{t-1} &amp;= \sqrt{\overline{\alpha}_t} \,\, \widehat{x}_{0}^t + \sqrt{1-\overline{\alpha}_t}</span>
<span class="sd">             \left(\sqrt{1-\zeta} \,\, \widehat{\varepsilon} + \sqrt{\zeta} \,\, \varepsilon_t\right),</span>
<span class="sd">             \end{aligned}</span>
<span class="sd">             \end{equation*}</span>

<span class="sd">    where :math:`D_\theta(\cdot,\sigma)` is a Gaussian denoiser network with noise level :math:`\sigma`</span>
<span class="sd">    and :math:`f(y, \cdot)` is the data fidelity</span>
<span class="sd">    term.</span>

<span class="sd">    .. note::</span>

<span class="sd">            The algorithm might require careful tunning of the hyperparameters :math:`\lambda` and :math:`\zeta` to</span>
<span class="sd">            obtain optimal results.</span>

<span class="sd">    :param torch.nn.Module model: a conditional noise estimation model</span>
<span class="sd">    :param float sigma: the noise level of the data</span>
<span class="sd">    :param deepinv.optim.DataFidelity data_fidelity: the data fidelity operator</span>
<span class="sd">    :param int max_iter: the number of iterations to run the algorithm (default: 100)</span>
<span class="sd">    :param float zeta: hyperparameter :math:`\zeta` for the sampling step (must be between 0 and 1). Default: 1.0.</span>
<span class="sd">    :param float lambda_: hyperparameter :math:`\lambda` for the data fidelity step</span>
<span class="sd">        (:math:`\rho_t = \lambda \frac{\sigma_n^2}{\bar{\sigma}_t^2}` in the paper where the optimal value range</span>
<span class="sd">         between 3.0 and 25.0 depending on the problem). Default: 7.0.</span>
<span class="sd">    :param bool verbose: if True, print progress</span>
<span class="sd">    :param str device: the device to use for the computations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">data_fidelity</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">zeta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">lambda_</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DiffPIR</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_</span> <span class="o">=</span> <span class="n">lambda_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_fidelity</span> <span class="o">=</span> <span class="n">data_fidelity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_end</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">20</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span> <span class="o">=</span> <span class="mi">1000</span>

        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_1m_alphas_cumprod</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduced_alpha_cumprod</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_alphas_cumprod</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_recip_alphas_cumprod</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_recipm1_alphas_cumprod</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha_beta</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rhos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise_schedule</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

<div class="viewcode-block" id="DiffPIR.get_alpha_beta">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DiffPIR.html#deepinv.sampling.DiffPIR.get_alpha_beta">[docs]</a>
    <span class="k">def</span> <span class="nf">get_alpha_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the alpha and beta sequences for the algorithm. This is necessary for mapping noise levels to timesteps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">betas</span>
        <span class="n">alphas_cumprod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">alphas</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># This is \overline{\alpha}_t</span>

        <span class="c1"># Useful sequences deriving from alphas_cumprod</span>
        <span class="n">sqrt_alphas_cumprod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alphas_cumprod</span><span class="p">)</span>
        <span class="n">sqrt_1m_alphas_cumprod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alphas_cumprod</span><span class="p">)</span>
        <span class="n">reduced_alpha_cumprod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span>
            <span class="n">sqrt_1m_alphas_cumprod</span><span class="p">,</span> <span class="n">sqrt_alphas_cumprod</span>
        <span class="p">)</span>  <span class="c1"># equivalent noise sigma on image</span>
        <span class="n">sqrt_recip_alphas_cumprod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">alphas_cumprod</span><span class="p">)</span>
        <span class="n">sqrt_recipm1_alphas_cumprod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">alphas_cumprod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">sqrt_1m_alphas_cumprod</span><span class="p">,</span>
            <span class="n">reduced_alpha_cumprod</span><span class="p">,</span>
            <span class="n">sqrt_alphas_cumprod</span><span class="p">,</span>
            <span class="n">sqrt_recip_alphas_cumprod</span><span class="p">,</span>
            <span class="n">sqrt_recipm1_alphas_cumprod</span><span class="p">,</span>
            <span class="n">betas</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DiffPIR.get_noise_schedule">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DiffPIR.html#deepinv.sampling.DiffPIR.get_noise_schedule">[docs]</a>
    <span class="k">def</span> <span class="nf">get_noise_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the noise schedule for the algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambda_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigma_ks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rhos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span><span class="p">):</span>
            <span class="n">sigmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reduced_alpha_cumprod</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">sigma_ks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sqrt_1m_alphas_cumprod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_alphas_cumprod</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">rhos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">rhos</span><span class="p">,</span> <span class="n">sigmas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">rhos</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">sigmas</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">))</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">seq</span><span class="p">)]</span>
        <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">rhos</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">,</span> <span class="n">seq</span></div>


<div class="viewcode-block" id="DiffPIR.find_nearest">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DiffPIR.html#deepinv.sampling.DiffPIR.find_nearest">[docs]</a>
    <span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the argmin of the nearest value in an array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">idx</span></div>


<div class="viewcode-block" id="DiffPIR.get_alpha_prod">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DiffPIR.html#deepinv.sampling.DiffPIR.get_alpha_prod">[docs]</a>
    <span class="k">def</span> <span class="nf">get_alpha_prod</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">beta_start</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">beta_end</span><span class="o">=</span><span class="mi">20</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num_train_timesteps</span><span class="o">=</span><span class="mi">1000</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the alpha sequences; this is necessary for mapping noise levels to timesteps when performing pure denoising.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">beta_start</span><span class="p">,</span> <span class="n">beta_end</span><span class="p">,</span> <span class="n">num_train_timesteps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
            <span class="n">betas</span>
        <span class="p">)</span>  <span class="c1"># .to(self.device) Removing this for now, can be done outside</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">betas</span>
        <span class="n">alphas_cumprod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">alphas</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># This is \overline{\alpha}_t</span>

        <span class="c1"># Useful sequences deriving from alphas_cumprod</span>
        <span class="n">sqrt_recip_alphas_cumprod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">alphas_cumprod</span><span class="p">)</span>
        <span class="n">sqrt_recipm1_alphas_cumprod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">alphas_cumprod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">sqrt_recip_alphas_cumprod</span><span class="p">,</span>
            <span class="n">sqrt_recipm1_alphas_cumprod</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DiffPIR.forward">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DiffPIR.html#deepinv.sampling.DiffPIR.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">physics</span><span class="p">:</span> <span class="n">deepinv</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">LinearPhysics</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the diffusion to obtain a random sample of the posterior distribution.</span>

<span class="sd">        :param torch.Tensor y: the measurements.</span>
<span class="sd">        :param deepinv.physics.LinearPhysics physics: the physics operator.</span>
<span class="sd">        :param float sigma: the noise level of the data.</span>
<span class="sd">        :param int seed: the seed for the random number generator.</span>
<span class="sd">        :param torch.Tensor x_init: the initial guess for the reconstruction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">physics</span><span class="o">.</span><span class="n">noise_model</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">):</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">physics</span><span class="o">.</span><span class="n">noise_model</span><span class="o">.</span><span class="n">sigma</span>  <span class="c1"># Then we overwrite the default values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rhos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise_schedule</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Initialization</span>
        <span class="k">if</span> <span class="n">x_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Necessary when x and y don&#39;t live in the same space</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">physics</span><span class="o">.</span><span class="n">A_adjoint</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_init</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">sqrt_recip_alphas_cumprod</span><span class="p">,</span> <span class="n">sqrt_recipm1_alphas_cumprod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha_prod</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)):</span>
                <span class="c1"># Current noise level</span>
                <span class="n">curr_sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                <span class="c1"># time step associated with the noise level sigmas[i]</span>
                <span class="n">t_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reduced_alpha_cumprod</span><span class="p">,</span> <span class="n">curr_sigma</span><span class="p">)</span>

                <span class="c1"># Denoising step</span>
                <span class="n">x_aux</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span>
                <span class="n">denoised</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x_aux</span><span class="p">,</span> <span class="n">curr_sigma</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">noise_est</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sqrt_recip_alphas_cumprod</span><span class="p">[</span><span class="n">t_i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">denoised</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">sqrt_recipm1_alphas_cumprod</span><span class="p">[</span><span class="n">t_i</span><span class="p">]</span>

                <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_recip_alphas_cumprod</span><span class="p">[</span><span class="n">t_i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_recipm1_alphas_cumprod</span><span class="p">[</span><span class="n">t_i</span><span class="p">]</span> <span class="o">*</span> <span class="n">noise_est</span>
                <span class="p">)</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># Data fidelity step</span>
                    <span class="n">x0_p</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span>
                    <span class="n">x0_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_fidelity</span><span class="o">.</span><span class="n">prox</span><span class="p">(</span>
                        <span class="n">x0_p</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">physics</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhos</span><span class="p">[</span><span class="n">t_i</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="n">x0</span> <span class="o">=</span> <span class="n">x0_p</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

                    <span class="c1"># Sampling step</span>
                    <span class="n">t_im1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reduced_alpha_cumprod</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                    <span class="p">)</span>  <span class="c1"># time step associated with the next noise level</span>
                    <span class="n">eps</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_alphas_cumprod</span><span class="p">[</span><span class="n">t_i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x0</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_1m_alphas_cumprod</span><span class="p">[</span>
                        <span class="n">t_i</span>
                    <span class="p">]</span>  <span class="c1"># effective noise</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_alphas_cumprod</span><span class="p">[</span><span class="n">t_im1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x0</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_1m_alphas_cumprod</span><span class="p">[</span><span class="n">t_im1</span><span class="p">]</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">eps</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_1m_alphas_cumprod</span><span class="p">[</span><span class="n">t_im1</span><span class="p">]</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="p">)</span>  <span class="c1"># sampling</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span>  <span class="c1"># back to [0, 1] range</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="DPS">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DPS.html#deepinv.sampling.DPS">[docs]</a>
<span class="k">class</span> <span class="nc">DPS</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Diffusion Posterior Sampling (DPS).</span>

<span class="sd">    This class implements the Diffusion Posterior Sampling algorithm (DPS) described in</span>
<span class="sd">    https://arxiv.org/abs/2209.14687.</span>

<span class="sd">    DPS is an approximation of a gradient-based posterior sampling algorithm,</span>
<span class="sd">    which has minimal assumptions on the forward model. The only restriction is that</span>
<span class="sd">    the measurement model has to be differentiable, which is generally the case.</span>

<span class="sd">    The algorithm writes as follows, for :math:`t` decreasing from :math:`T` to :math:`1`:</span>

<span class="sd">    .. math::</span>

<span class="sd">            \begin{equation*}</span>
<span class="sd">            \begin{aligned}</span>
<span class="sd">            \widehat{\mathbf{x}}_{t} &amp;= D_{\theta}(\mathbf{x}_t, \sqrt{1-\overline{\alpha}_t}/\sqrt{\overline{\alpha}_t})</span>
<span class="sd">            \\</span>
<span class="sd">            \mathbf{g}_t &amp;= \nabla_{\mathbf{x}_t} \log p( \widehat{\mathbf{x}}_{t}(\mathbf{x}_t) | \mathbf{y} ) \\</span>
<span class="sd">            \mathbf{\varepsilon}_t &amp;= \mathcal{N}(0, \mathbf{I}) \\</span>
<span class="sd">            \mathbf{x}_{t-1} &amp;= a_t \,\, \mathbf{x}_t</span>
<span class="sd">            + b_t \, \, \widehat{\mathbf{x}}_t</span>
<span class="sd">            + \tilde{\sigma}_t \, \, \mathbf{\varepsilon}_t + \mathbf{g}_t,</span>
<span class="sd">            \end{aligned}</span>
<span class="sd">            \end{equation*}</span>

<span class="sd">    where :math:`\denoiser{\cdot}{\sigma}` is a denoising network for noise level :math:`\sigma`,</span>
<span class="sd">    :math:`\eta` is a hyperparameter, and the constants :math:`\tilde{\sigma}_t, a_t, b_t` are defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">            \begin{equation*}</span>
<span class="sd">            \begin{aligned}</span>
<span class="sd">              \tilde{\sigma}_t &amp;= \eta \sqrt{ (1 - \frac{\overline{\alpha}_t}{\overline{\alpha}_{t-1}})</span>
<span class="sd">              \frac{1 - \overline{\alpha}_{t-1}}{1 - \overline{\alpha}_t}} \\</span>
<span class="sd">              a_t &amp;= \sqrt{1 - \overline{\alpha}_{t-1} - \tilde{\sigma}_t^2}/\sqrt{1-\overline{\alpha}_t} \\</span>
<span class="sd">              b_t &amp;= \sqrt{\overline{\alpha}_{t-1}} - \sqrt{1 - \overline{\alpha}_{t-1} - \tilde{\sigma}_t^2}</span>
<span class="sd">              \frac{\sqrt{\overline{\alpha}_{t}}}{\sqrt{1 - \overline{\alpha}_{t}}}.</span>
<span class="sd">            \end{aligned}</span>
<span class="sd">            \end{equation*}</span>

<span class="sd">    :param torch.nn.Module model: a denoiser network that can handle different noise levels</span>
<span class="sd">    :param deepinv.optim.DataFidelity data_fidelity: the data fidelity operator</span>
<span class="sd">    :param int max_iter: the number of diffusion iterations to run the algorithm (default: 1000)</span>
<span class="sd">    :param float eta: DDIM hyperparameter which controls the stochasticity</span>
<span class="sd">    :param bool verbose: if True, print progress</span>
<span class="sd">    :param str device: the device to use for the computations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">data_fidelity</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">eta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="n">save_iterates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DPS</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_fidelity</span> <span class="o">=</span> <span class="n">data_fidelity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_end</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">20</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_iterates</span> <span class="o">=</span> <span class="n">save_iterates</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_cumprod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_alpha_betas</span><span class="p">()</span>

<div class="viewcode-block" id="DPS.compute_alpha_betas">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DPS.html#deepinv.sampling.DPS.compute_alpha_betas">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_alpha_betas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Get the beta and alpha sequences for the algorithm. This is necessary for mapping noise levels to timesteps.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">alpha_cumprod</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">betas</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> <span class="n">betas</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">betas</span><span class="p">,</span> <span class="n">alpha_cumprod</span></div>


    <span class="k">def</span> <span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_cumprod</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">alpha_cumprod</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="DPS.forward">
<a class="viewcode-back" href="../../../stubs/deepinv.sampling.DPS.html#deepinv.sampling.DPS.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">physics</span><span class="p">:</span> <span class="n">deepinv</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">Physics</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the diffusion to obtain a random sample of the posterior distribution.</span>

<span class="sd">        :param torch.Tensor y: the measurements.</span>
<span class="sd">        :param deepinv.physics.LinearPhysics physics: the physics operator.</span>
<span class="sd">        :param int seed: the seed for the random number generator.</span>
<span class="sd">        :param torch.Tensor x_init: the initial guess for the reconstruction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Initialization</span>
        <span class="k">if</span> <span class="n">x_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Necessary when x and y don&#39;t live in the same space</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">physics</span><span class="o">.</span><span class="n">A_adjoint</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_init</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">skip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_train_timesteps</span><span class="p">,</span> <span class="n">skip</span><span class="p">)</span>
        <span class="n">seq_next</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">time_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">seq_next</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_iterates</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">time_pairs</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">next_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

            <span class="n">at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_cumprod</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">long</span><span class="p">())</span>
            <span class="n">at_next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_cumprod</span><span class="p">,</span> <span class="n">next_t</span><span class="o">.</span><span class="n">long</span><span class="p">())</span>

            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">enable_grad</span><span class="p">():</span>
                <span class="n">xt</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># 1. Denoising</span>
                <span class="c1"># we call the denoiser using standard deviation instead of the time step.</span>
                <span class="n">aux_x</span> <span class="o">=</span> <span class="n">xt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span>
                <span class="n">x0_t</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">aux_x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span> <span class="o">/</span> <span class="n">at</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="n">x0_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x0_t</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># optional</span>

                <span class="c1"># DPS</span>
                <span class="n">l2_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_fidelity</span><span class="p">(</span><span class="n">x0_t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">physics</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">norm_grad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">outputs</span><span class="o">=</span><span class="n">l2_loss</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">xt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">norm_grad</span> <span class="o">=</span> <span class="n">norm_grad</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

            <span class="n">c1</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">at</span> <span class="o">/</span> <span class="n">at_next</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">at_next</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">at</span><span class="p">))</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">at_next</span><span class="p">)</span> <span class="o">-</span> <span class="n">c1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

            <span class="c1"># 3. noise step</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">xt</span><span class="p">)</span>

            <span class="c1"># 4. DDPM(IM) step</span>
            <span class="n">xt_next</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">at_next</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span> <span class="o">-</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">at</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">())</span> <span class="o">*</span> <span class="n">x0_t</span>
                <span class="o">+</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">epsilon</span>
                <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">xt</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
                <span class="o">-</span> <span class="n">norm_grad</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_iterates</span><span class="p">:</span>
                <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xt_next</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">))</span>
            <span class="n">xt</span> <span class="o">=</span> <span class="n">xt_next</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_iterates</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xt</span></div>
</div>



<span class="c1"># if __name__ == &quot;__main__&quot;:</span>
<span class="c1">#     import deepinv as dinv</span>
<span class="c1">#     from deepinv.models.denoiser import Denoiser</span>
<span class="c1">#     import torchvision</span>
<span class="c1">#     from deepinv.utils.metric import cal_psnr</span>
<span class="c1">#</span>
<span class="c1">#     device = dinv.utils.get_freer_gpu() if torch.cuda.is_available() else &quot;cpu&quot;</span>
<span class="c1">#</span>
<span class="c1">#     x = torchvision.io.read_image(&quot;../../datasets/celeba/img_align_celeba/085307.jpg&quot;)</span>
<span class="c1">#     x = x.unsqueeze(0).float().to(device) / 255</span>
<span class="c1">#</span>
<span class="c1">#     sigma_noise = 0.01</span>
<span class="c1">#     # physics = dinv.physics.Denoising()</span>
<span class="c1">#</span>
<span class="c1">#     # physics = dinv.physics.BlurFFT(img_size=x.shape[1:], filter=dinv.physics.blur.gaussian_blur(sigma=1.),</span>
<span class="c1">#     #                               device=device)</span>
<span class="c1">#     physics = dinv.physics.Decolorize()</span>
<span class="c1">#     # physics = dinv.physics.Inpainting(</span>
<span class="c1">#     #   mask=0.5, tensor_size=(3, 218, 178), device=dinv.device</span>
<span class="c1">#     # )</span>
<span class="c1">#     # physics.mask *= (torch.rand_like(physics.mask))</span>
<span class="c1">#     physics.noise_model = dinv.physics.GaussianNoise(sigma_noise)</span>
<span class="c1">#</span>
<span class="c1">#     y = physics(x)</span>
<span class="c1">#     model_spec = {</span>
<span class="c1">#         &quot;name&quot;: &quot;drunet&quot;,</span>
<span class="c1">#         &quot;args&quot;: {&quot;device&quot;: device, &quot;pretrained&quot;: &quot;download&quot;},</span>
<span class="c1">#     }</span>
<span class="c1">#</span>
<span class="c1">#     denoiser = Denoiser(model_spec=model_spec)</span>
<span class="c1">#</span>
<span class="c1">#     f = DDRM(</span>
<span class="c1">#         denoiser=denoiser,</span>
<span class="c1">#         etab=1.0,</span>
<span class="c1">#         sigma_noise=sigma_noise,</span>
<span class="c1">#         sigmas=np.linspace(1, 0, 100),</span>
<span class="c1">#         verbose=True,</span>
<span class="c1">#     )</span>
<span class="c1">#</span>
<span class="c1">#     xhat = f(y, physics)</span>
<span class="c1">#     dinv.utils.plot(</span>
<span class="c1">#         [physics.A_adjoint(y), x, xhat], titles=[&quot;meas.&quot;, &quot;ground-truth&quot;, &quot;xhat&quot;]</span>
<span class="c1">#     )</span>
<span class="c1">#</span>
<span class="c1">#     print(f&quot;PSNR 1 sample: {cal_psnr(x, xhat):.2f} dB&quot;)</span>
<span class="c1">#     # print(f&#39;mean PSNR sample: {cal_psnr(x, denoiser(y, sigma_noise)):.2f} dB&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     # sampler = dinv.sampling.DiffusionSampler(f, max_iter=10, save_chain=True, verbose=True)</span>
<span class="c1">#     # xmean, xvar = sampler(y, physics)</span>
<span class="c1">#</span>
<span class="c1">#     # chain = sampler.get_chain()</span>
<span class="c1">#     # distance = np.zeros((len(chain)))</span>
<span class="c1">#     # for k, xhat in enumerate(chain):</span>
<span class="c1">#     #    dist = (xhat - xmean).pow(2).mean()</span>
<span class="c1">#     #    distance[k] = dist</span>
<span class="c1">#     # distance = np.sort(distance)</span>
<span class="c1">#     # thres = distance[int(len(distance) * .95)]  #</span>
<span class="c1">#     # err = (x - xmean).pow(2).mean()</span>
<span class="c1">#     # print(f&#39;Confidence region: {thres:.2e}, error: {err:.2e}&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     # xstdn = xvar.sqrt()</span>
<span class="c1">#     # xstdn_plot = xstdn.sum(dim=1).unsqueeze(1)</span>
<span class="c1">#</span>
<span class="c1">#     # error = (xmean - x).abs()  # per pixel average abs. error</span>
<span class="c1">#     # error_plot = error.sum(dim=1).unsqueeze(1)</span>
<span class="c1">#</span>
<span class="c1">#     # print(f&#39;Correct std: {(xstdn&gt;error).sum()/np.prod(xstdn.shape)*100:.1f}%&#39;)</span>
<span class="c1">#     # error = (xmean - x)</span>
<span class="c1">#     # dinv.utils.plot_debug(</span>
<span class="c1">#     #    [physics.A_adjoint(y), x, xmean, xstdn_plot, error_plot], titles=[&quot;meas.&quot;, &quot;ground-truth&quot;, &quot;mean&quot;, &quot;std&quot;, &quot;error&quot;]</span>
<span class="c1">#     # )</span>
<span class="c1">#</span>
<span class="c1">#     # print(f&#39;PSNR 1 sample: {cal_psnr(x, chain[0]):.2f} dB&#39;)</span>
<span class="c1">#     # print(f&#39;mean PSNR sample: {cal_psnr(x, xmean):.2f} dB&#39;)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, DeepInv.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NSEKFKYSGR"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-NSEKFKYSGR', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>