
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/basics/demo_custom_prior.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_basics_demo_custom_prior.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_basics_demo_custom_prior.py:


Image deblurring with custom deep explicit prior.
====================================================================================================

In this example, we show how to solve a deblurring inverse problem using an explicit prior.

Here we use the simple L2 prior that penalizes the squared norm of the reconstruction, with an ADMM algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 10-22

.. code-block:: default

    import deepinv as dinv
    from pathlib import Path
    import torch
    from torch.utils.data import DataLoader
    from deepinv.optim.prior import Prior
    from deepinv.optim.data_fidelity import L2
    from deepinv.optim.optimizers import optim_builder
    from deepinv.training_utils import test
    from torchvision import transforms
    from deepinv.utils.demo import load_dataset









.. GENERATED FROM PYTHON SOURCE LINES 23-26

Setup paths for data loading and results.
--------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 26-40

.. code-block:: default


    # Setup paths for data loading, results and checkpoints.
    BASE_DIR = Path(".")
    ORIGINAL_DATA_DIR = BASE_DIR / "datasets"
    DATA_DIR = BASE_DIR / "measurements"
    RESULTS_DIR = BASE_DIR / "results"
    DEG_DIR = BASE_DIR / "degradations"

    # Set the global random seed from pytorch to ensure reproducibility of the example.
    torch.manual_seed(0)

    device = dinv.utils.get_freer_gpu() if torch.cuda.is_available() else "cpu"









.. GENERATED FROM PYTHON SOURCE LINES 41-46

Load base image datasets and degradation operators.
--------------------------------------------------------------------
In this example, we use the CBSD68 dataset from the paper of Zhang et al. (2017) and the motion blur kernels from
`Levin et al. (2009) <https://ieeexplore.ieee.org/abstract/document/5206815/>`_.


.. GENERATED FROM PYTHON SOURCE LINES 46-59

.. code-block:: default


    # Set up the variable to fetch dataset and operators.
    method = "L2_prior"
    dataset_name = "set3c"
    operation = "deblur"
    img_size = 256
    dataset_path = ORIGINAL_DATA_DIR / dataset_name
    val_transform = transforms.Compose(
        [transforms.CenterCrop(img_size), transforms.ToTensor()]
    )
    dataset = load_dataset(dataset_name, ORIGINAL_DATA_DIR, transform=val_transform)









.. GENERATED FROM PYTHON SOURCE LINES 60-67

Define physics operator
--------------------------------------------------------
We use the :class:`deepinv.physics.BlurFFT` operator from the physics module to generate a dataset of blurred images.
The BlurFFT class performs the convolutions via the Fourier transform.

In this example, we choose a gaussian kernel with standard deviation 3, and we add a Gaussian noise with standard
deviation 0.03.

.. GENERATED FROM PYTHON SOURCE LINES 67-83

.. code-block:: default



    # Generate a Gaussian blur filter.
    filter_torch = dinv.physics.blur.gaussian_blur(sigma=(3, 3))
    noise_level_img = 0.03  # Gaussian Noise standard deviation for the degradation
    n_channels = 3  # 3 for color images, 1 for gray-scale images

    # The BlurFFT instance from physics enables to compute efficently backward operators with Fourier transform.
    p = dinv.physics.BlurFFT(
        img_size=(n_channels, img_size, img_size),
        filter=filter_torch,
        device=device,
        noise_model=dinv.physics.GaussianNoise(sigma=noise_level_img),
    )









.. GENERATED FROM PYTHON SOURCE LINES 84-86

Generate a dataset of blurred images
--------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 86-103

.. code-block:: default


    # Use parallel dataloader if using a GPU to fasten training, otherwise, as all computes are on CPU, use synchronous
    # data loading.
    num_workers = 4 if torch.cuda.is_available() else 0
    n_images_max = 3  # Maximal number of images to restore from the input dataset

    measurement_dir = DATA_DIR / dataset_name / operation
    deepinv_dataset_path = dinv.datasets.generate_dataset(
        train_dataset=dataset,
        test_dataset=None,
        physics=p,
        device=device,
        save_dir=measurement_dir,
        train_datapoints=n_images_max,
        num_workers=num_workers,
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Computing train measurement vectors from base dataset...
      0%|          | 0/2 [00:00<?, ?it/s]    100%|██████████| 2/2 [00:00<00:00, 47.27it/s]
    Dataset has been saved in measurements/set3c/deblur




.. GENERATED FROM PYTHON SOURCE LINES 104-117

Set up the optimization algorithm to solve the inverse problem.
--------------------------------------------------------------------------------------------
We use the :class:`deepinv.optim.optimizers.optim_builder` function to instantiate the optimization algorithm.

The optimization algorithm is a proximal gradient descent algorithm that solves the following optimization problem:

.. math::

  \min_{x} \frac{1}{2} \|y - Ax\|_2^2 + \rho \|x\|_2^2

where :math:`A` is the forward blurring operator, :math:`y` is the measurement
and :math:`\rho` is a regularization parameter.


.. GENERATED FROM PYTHON SOURCE LINES 117-167

.. code-block:: default



    # Create a custom prior which inherits from the base Prior class.
    class L2Prior(Prior):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.explicit_prior = True

        def g(self, x, args, **kwargs):
            g = 0.5 * torch.norm(x.view(x.shape[0], -1), p=2, dim=-1) ** 2
            return g


    # Specify the custom prior
    prior = L2Prior()

    # Select the data fidelity term
    data_fidelity = L2()

    # Specific parameters for restoration with the given prior (Note that these parameters have not been optimized here)
    params_algo = {"stepsize": 1, "lambda": 0.1}

    # Logging parameters
    verbose = True
    plot_metrics = True  # compute performance and convergence metrics along the algorithm, curved saved in RESULTS_DIR

    # Parameters of the algorithm to solve the inverse problem
    early_stop = True  # Stop algorithm when convergence criteria is reached
    crit_conv = "cost"  # Convergence is reached when the difference of cost function between consecutive iterates is
    # smaller than thres_conv
    thres_conv = 1e-5
    backtracking = False  # use backtraking to automatically adjust the stepsize
    max_iter = 500  # Maximum number of iterations

    # Instantiate the algorithm class to solve the IP problem.
    model = optim_builder(
        iteration="ADMM",
        prior=prior,
        g_first=False,
        data_fidelity=data_fidelity,
        params_algo=params_algo,
        early_stop=early_stop,
        max_iter=max_iter,
        crit_conv=crit_conv,
        thres_conv=thres_conv,
        backtracking=backtracking,
        verbose=verbose,
    )









.. GENERATED FROM PYTHON SOURCE LINES 168-172

Evaluate the reconstruction algorithm on the problem.
---------------------------------------------------------------

We can use the :func:`deepinv.utils.test` function to evaluate the reconstruction algorithm on a test set.

.. GENERATED FROM PYTHON SOURCE LINES 172-195

.. code-block:: default



    batch_size = 1
    wandb_vis = False  # plot curves and images in Weight&Bias
    plot_images = True  # plot results


    dataset = dinv.datasets.HDF5Dataset(path=deepinv_dataset_path, train=True)
    dataloader = DataLoader(
        dataset, batch_size=batch_size, num_workers=num_workers, shuffle=False
    )

    test(
        model=model,
        test_dataloader=dataloader,
        physics=p,
        device=device,
        plot_images=plot_images,
        save_folder=RESULTS_DIR / method / operation / dataset_name,
        plot_metrics=plot_metrics,
        verbose=verbose,
        wandb_vis=wandb_vis,
    )



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/basics/images/sphx_glr_demo_custom_prior_001.png
         :alt: Input, Linear, Recons., GT
         :srcset: /auto_examples/basics/images/sphx_glr_demo_custom_prior_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/basics/images/sphx_glr_demo_custom_prior_002.png
         :alt: $PSNR(x_k)$, $F(x_k)$, Residual $\frac{||x_{k+1} - x_k||}{||x_k||}$
         :srcset: /auto_examples/basics/images/sphx_glr_demo_custom_prior_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/basics/images/sphx_glr_demo_custom_prior_003.png
         :alt: $PSNR(x_k)$, $F(x_k)$, Residual $\frac{||x_{k+1} - x_k||}{||x_k||}$
         :srcset: /auto_examples/basics/images/sphx_glr_demo_custom_prior_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/basics/images/sphx_glr_demo_custom_prior_004.png
         :alt: $PSNR(x_k)$, $F(x_k)$, Residual $\frac{||x_{k+1} - x_k||}{||x_k||}$
         :srcset: /auto_examples/basics/images/sphx_glr_demo_custom_prior_004.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Processing data of operator 1 out of 1
      0%|          | 0/3 [00:00<?, ?it/s]     33%|███▎      | 1/3 [00:26<00:52, 26.21s/it]Iteration 36, current converge crit. = 2.77E-06, objective = 1.00E-05 
     67%|██████▋   | 2/3 [00:28<00:12, 12.14s/it]Iteration 45, current converge crit. = 1.07E-06, objective = 1.00E-05 
    100%|██████████| 3/3 [00:31<00:00,  7.83s/it]    100%|██████████| 3/3 [00:31<00:00, 10.40s/it]
    Test PSNR: Linear rec.: 16.91+-2.29 dB | Model: 19.75+-2.26 dB. 

    (19.75107192993164, 2.2591548061178632, 16.9091952641805, 2.2942947546189876)




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 31.828 seconds)


.. _sphx_glr_download_auto_examples_basics_demo_custom_prior.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_custom_prior.py <demo_custom_prior.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_custom_prior.ipynb <demo_custom_prior.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
